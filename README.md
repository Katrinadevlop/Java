# Java и Kotlin практика 

Этот репозиторий содержит мои учебные проекты и практические задания по курсу Android-разработчик от компании Нетология, написанные на языке Java и Kotlin.  

## Сводка тем:
1. Основы Java и Kotlin: переменные, ввод/вывод, арифметика, условия, циклы.
2. ООП и классы: наследование, инкапсуляция, переопределение методов, работа с объектами.
3. Методы и поля: статика, геттеры, конструкция Math, работа с String.
4. Коллекции: List, Queue, Map, массивы и двумерные массивы.
5. Алгоритмы и логика: поворот матриц, поиск подстрок, формулы расчёта.
6. Работа с пользователем: ввод команд, циклы обработки, проверки.
7. Исключения и валидация: IllegalArgumentException, IllegalStateException.
8. Полиморфизм и интерфейсы: Logger, TaxSystem, Account.
9. Git и GitHub: работа с ветками, revert, merge, конфликты, GitHub Pages.
10. Служебные утилиты: PasswordChecker, RandomBox, DoubleBox.
11. Проектная работа: генерация ASCII-графики, консольные игры и бизнес-логика.

## Доделать:
1. 16 задание

## Задания:
Main - 
- **1 задание**.
Напишите программу, которая при запуске выводит ваше имя и фамилию на латинице. 
- **2 задание**.
Напишите программу, в которой заведены две целочисленные переменные: income для хранения размера доходов, spending для хранения размера расходов
Программа должна выводить на экран сообщение о том, сколько денег осталось на счету.

---

Homework 2 -
- **1 задание**.
Ваша задача написать калькулятор для расчёта пошлины для провоза товара. Пошлина будет рассчитывается по следующему принципу: 1 копейка за каждый рубль цены товара, 100 рублей за каждый килограмм товара.
Копейки в итоговой сумме пошлины можно не учитывать, оставляя только рубли. 
Программа должна приветствовать пользователя, спрашивать стоимость в рублях и вес товара в кг (всё целые числа), а в ответ сообщать размер пошлины.
Логика рассчёта пошлины по характеристикам товара должна быть вынесена в отдельный статический метод. Он должен: принимать два параметра - цену и вес товара (целые числа), возвращать посчитанную сумму пошлины.
- **2 задание**.
Вынесите статиечский метод в отдельный класс CustomsService, который лежал бы в пакете ru.netology.service.
Ставка пошлины на вес товара должна быть вынесена в статическое поле класса CustomsService.

---

Homework 3 -
- **1 задание**.
Нужно написать программу, которая будет рассчитывать количество дней в году. Для расчета количества дней в году требуется знать несколько правил:
  - В високосном году 366 дней, в обычном 365.
  - Високосный год — это год, номер которого делится без остатка на 400 (например 2000 или 2400), либо делится на 4 но не делится на 100 (например 2008, 2096, но не 2100).

    Схема работы программы:
  - Вывод сообщения в консоли Введите год в формате "yyyy".
  - Ввод года в формате yyyy (например 2004).
  - Чтение значения из консоли и расчет количества дней.
  - Результат работы программы: напечатать в консоли количество дней в году Количество дней 365 или Количество дней 366.
- **2 задание**.
Нужно написать программу, которая будет играть с пользователем в следующую игру. Каждый ход программа спрашивает у него два числа: год и число дней в этом году.
Вы проверяете, правильно ли пользователь указал количество дней в этом году и, если правильно, повторяете ход. В противном случае игра завершается.
По окончании игры напишите пользователю сколько раз он угадал, это и будет количество набранных очков в игре.

---

Homework 4 -
- **1 задание**.
Нужно написать программу-помощника индивидуальному предпринимателю (далее - ИП), которая помогает ему выбрать лучшую систему налогообложения.
ИП будет заносить суммы доходов и расходов, а программа будет выбирать для него лучшую систему налогообложения из двух:
  - УСН доходы - налог 6% от доходов;
  - УСН доходы минус расходы - налог 15% от разницы доходов и расходов.
  - Налоги можно считать целочисленными.


  Функционал программы
  - Ввод сумм доходов и расходов ИП;
  - ИП может несколько раз вносить доходы и расходы, они должны суммироваться с введёнными ранее данными;
  - При выборе ИП опции определения наиболее выгодной системы налогообложения, программа должна вывести название такой системы (УСН доходы или УСН доходы минус расходы);
  - Если налоги на обеих системах равны, об этом должно быть сообщено пользователю (например, сообщением Можете выбрать любую систему налогообложения);
  - При выводе самой выгодной системы налогообложения, программа должна вывести также сумму, которую удастся сэкономить, если выбрать эту систему, а также налоги на каждой из доступных систем налогообложения;
  - Программа должна завершаться при вводе слова end;
  - Нужно помнить, что налог не может быть отрицательным;
  - Программа должна быть структурирована в методы.
    
---

Homework 5 -
- **1 задание**.
Ваша задача - найти какое количество раз текст в PATTERN повторяется в TEXT. Повторения могут пересекаться друг с другом.
Предлагаем циклом перебрать все возможные позиции в TEXT в которых может начинаться PATTERN.
При переборе каждую позицию проверять циклом, перебирая символы в PATTERN и символы, которые идут начиная с перебираемой позиции.
Если при проверке хотя бы один из символов не совпадёт - позиция не подходит и переходим к следующей. В противном случае нужно увеличить счётчик повторений count.

---

Homework 6 -
- **1 задание**.
Разработайте класс Book, объект которого содержит в себе следующую информацию:
  - title - название книги;
  - releaseYear - год выпуска;
  - author - автор;
  - pages - количество страниц.
 
  И методы:
  - isBig(), возвращающий ответ на вопрос, является ли книга большой; книгу считаем большой, если в ней больше 500 страниц (какой тип данных лучше всего подходит для ответа "да" или "нет"?);
  - matches(String word), возвращающий ответ на вопрос, содержится ли в описании книги (названии или в имени автора) переданное параметром слово (для этого используйте метод contains, который есть у объектов класса String); метод потенциально может использоваться для поиска по книгам в будущем (какой тип данных лучше всего подходит для ответа "да" или "нет"?);
  - estimatePrice(), возвращающий оценку стоимости книги (целое число в рублях) по формуле 3 рубля за страницу, но не меньше 250 рублей.
У книги должен быть один конструктор, позволяющий заполнить все поля создаваемого объекта из одноимённых параметров.

- **2 задание**.
Добавьте класс Author с полями name (имя), surname (фамилия) и rating (рейтинг, целое число), которые задаются конструктором.
В класс книги теперь автор должен передаваться и храниться как объект класса Author. Метод matches должен проверять не только по имени автора, но и по фамилии.
Цена книги теперь рассчитывается как 3 рубля за страницу, умноженное на квадратный корень из рейтинга, после чего округлённое вниз, но не меньше 250 рублей.

--- 

Homework 7 -
- **1 задание**.
Вы пишете программу, планирующую продуктовую корзину.
У вас есть список доступных продуктов в одном массиве и соответствующая им цена в другом массиве.
Пользователь на повторе вводит номер продукта из первого списка и количество продуктов этого вида, которое хочет купить.
Программа добавляет указанное количество выбранного продукта в итоговую продуктовую корзину.
Действие повторяется до тех пор, пока пользователь не введет команду "end". Только после этого выводится вся корзина выбранных товаров и итоговая сумма.
Должна быть возможность ввода пользователем одной строкой номера продукта и количества для добавления в корзину.
Пользователь может добавлять несколько раз один и тот же товар в корзину, в этом случае он должен суммироваться.

---
  
Homework 8 -
- **1 задание**.
Дано: двумерная матрица 8 на 8 из случайных чисел от 0 до 255 (спектр цветов GrayScale). Напишите алгоритм "поворота" такой матрицы на 90 градусов по часовой стрелке.
Функционал программы:
  - Создание матрицы в программе;
  - Вывод матрицы до поворота;
  - Разворот матрицы;
  - Вывод матрицы после поворота на 90 градусов.
  - Вывод должен быть вынесен в отдельный метод, с помощью которого будут выведены и исходная, и перевёрнутая матрицы
- **2 задание**.
Добавьте в задачу возможности выбора пользователем угла поворота: 90, 180 или 270 градусов.

---

Homework 9 - 
- **1 задание**.
Логика контроля доходов и расходов будет в одном классе, а логика системы налогооблажения — в других. Полиморфизм понадобится, чтобы это без сбоев работало друг с другом.
Создайте класс Company. Каждая компания должна знать свои title (название), debit (доходы), credit (расходы) и taxSystem (систему налогооблажения, о ней ниже).
В этом классе должен быть только один конструктор, задающий название компании и систему налогооблажения, принимая их параметрами. Доходы и расходы изначально равны нулю.
У компании должен быть метод shiftMoney(int amount), который работает так:
  - если amount больше 0, то увеличивается значение debit на amount;
  - если amount меньше 0, то увеличивается значение credit на Math.abs(amount);
  - если amount равен 0, то ничего не происходит.
Теперь поговорим про системы налогооблажения. Все системы налогооблажения будут наследоваться от класса TaxSystem, переопределяя метод расчёта налогов по доходам и расходам:

```java
package taxes;

public class TaxSystem {
    public int calcTaxFor(int debit, int credit) {
        return 0;
    }
}
```
  - Реализуйте два класса налоговых систем:
     - УСН доходы — налог 6% от доходов;
     - УСН доходы минус расходы — налог 15% от разницы доходов и расходов.

    Помните, что налог не может быть отрицательным. В таком случае налог должен быть 0.
    Компания должна работать с любой системой налогооблажения, поэтому внутри класса Company используйте класс TaxSystem в указании типов ячеек.
    По правилу полиморфизма, в них можно будет передать объекты любых наследников этого класса, с конкретными логиками расчёта налогов.
    Добавьте в класс Company сеттер для смены системы налогооблажения. 

  - Добавьте в класс Company метод payTaxes(), который:
    - рассчитает с помощью выбранной этой компанией системы налогооблажения размер налогов;
    - выведет сообщение на экран вида: Компания <название> уплатила налог в размере: <сумма> руб.;
    - обнулит счётчики debit и credit.

- **2 задание**.
Создайте в вашем проекте дополнительный класс Deal, объект которого будет описывать сделку, что может провернуть компания.
Каждая сделка сопровождается комментарием (comment), суммой расходов (creditChange) и суммой доходов (debitChange). Создайте конструктор, который принимает эти три параметра.
Создайте два наследника: Sale (продажа) и Expenditure (трата). Объект Sale должен конструироваться от названия товара и его цены, являясь сделкой с комментарием (comment) вида
Продажа <название товара> на <цена> руб., debitChange размером в цену и нулевым creditChange.
Объект Expenditure должен конструироваться от названия товара и его цены, являясь сделкой с комментарием (comment) вида Покупка <название товара> на <цена> руб.,
creditChange размером в цену и нулевым debitChange.

  В классе Company создайте метод int applyDeals(Deal[] deals), в результате вызова которого:
  - компания применяет все сделки из массива сделок (т. е. увеличивает credit на creditChange, debit на debitChange);
  - выплачивает все налоги;
  - возвращает из метода разницу доходов и расходов, которая была на момент старта уплаты налогов.
    
---


Homework 9.1 - 
- **1 задание**.
Перед вами три класса - класс Робота, Умного робота и Main. В рамках этого задания они все даны в одном файле. Объект класса робота умеет перемещаться в двумерном пространстве и помнит свои координаты (x и y). Умный же робот умеет ещё и считать количество сделанных шагов. Ваша задача написать реализацию класса умного робота, который отнаследован от класса обычного робота. Никакие другие классы менять нельзя, даже незначительно (например, модификаторы доступа).

---

Homeworkз 10 -
- **1 задание**.
Создайте систему классов для описания двух видов счетов:
  - SimpleAccount — обычный счёт, с которого можно платить, пока на нём есть деньги, и пополнять сколько угодно раз.
  - CreditAccount — кредитный счёт, который может уходить в минус до кредитного лимита, указанного в конструкторе, но не может уходить в плюс.
  - Оба счёта логично сделать наследниками общего класса Account.

  У любого счёта должно быть три операции. Никакая из трёх операций ничего не должна выводить на экран:
  - boolean add(long amount) — пополнение счёта на amount, возвращает true, если пополнение успешно, и false, если иначе;
  - boolean pay(long amount) — покупка со счёта на amount, возвращает true, если пукупка успешна, и false, если иначе;
  - boolean transfer(Account account, long amount) — перевод денег со счёта, у которого был вызван метод, на счёт из параметра на сумму в размере amount, возвращает true, если пополнение успешно, и false, если иначе;
  - long getBalance() — метод возвращает текущий баланс на счёте.

- **2 задание**.
Перед вами интерфейс Logger, описывающий объекты, умеющие логировать, т. е. журналировать сообщения из программы. В нашем случае журналом будет консоль:
```java
public interface Logger {
    void log(String msg);
}
```
- Напишите две реализации этого интерфейса: SimpleLogger и SmartLogger.
  - Логгер типа SimpleLogger при вызове метода log должен выводить на экран текст вида: [2022-12-17T19:04:28.907390] <сообщение>,
  где в квадратных скобках указаны точная дата и время вызова метода. Его можно получить с помощью LocalDateTime.now(), 
  возвращённый этой командой объект можно напрямую склеивать с текстом через +.
  - Логгер типа SmartLogger должен иметь текст вида INFO#13 [2022-12-17T19:04:28.907390] <сообщение>. 
  Вместо 13 следует указать порядковый номер вызова метода log у этого логгера (нумеровать с 1). 
В случае, если в сообщении есть слово error (всё равно в каком регистре), то INFO следует заменить на ERROR.

---
  
Homework 11 -
- **1 задание**.
Нам предстоит написать класс PasswordChecker, объект которого умеет проверять надёжность пароля.

  У этого класса должны быть методы-настройки:
  - setMinLength — сеттер установки минимально допустимой длины пароля. Если в сеттер передали недопустимое значение (отрицательное число), то должно выкинуться исключение IllegalArgumentException, т. е. исключение недопустимого аргумента, с соответствующим сообщением;
  - setMaxRepeats — сеттер установки максимально допустимого количества повторений символа подряд. Если в сеттер передали недопустимое значение (отрицательное число или 0), то должно выкинуться исключение IllegalArgumentException, т. е. исключение недопустимого аргумента, с соответствующим сообщением.

  И метод проверки boolean verify(String password), который проверяет переданный пароль на эти два критерия. Если пароль проходит, возвращает true, не проходит — false. Если до вызова метода verify хотя бы одна из двух вышеперечисленных настроек не была выставлена чекеру, то в нём кидается исключение IllegalStateException, т. е. исключение недопустимого состояния, с соответствующим сообщением.
  В main спросите у пользователя настройки для чекера, создайте объект чекера и в бесконечном цикле — до ввода end — спрашивайте у пользователя пароли, которые затем проверяйте чекером и выводите на экран результат. Если пользователь ввёл недопустимые настройки, то программа не должна вылетать с исключением. Поймайте его, выведите на экран сообщение об ошибке и завершите программу.
  
---
  
Homework 12 -
- **1 задание**.
Перед вами готовый дженерик-класс RandomBox. В неё можно положить любой объект и ключ к нему.
Вынуть положенный объект можно только если правильно указать ключ, иначе в ответе будет null.
Вашей задачей будет реализовать дженерик-класс DoubleBox, который позволяет положить в себя два объекта со своими ключами.
Реализовывать нужно через хранение объектов в RandomBox-ах (уже даны в полях).
Никакие другие классы кроме DoubleBox менять нельзя.

---
  
Homework 13 -
- **1 задание**.
Реализуйте программу, которая помогает пользователю управлять списком дел. Дела можно считать уникальными, т. е. без повторов.

  Должны быть операции:
  - добавления нового дела в список;
  - вывода всех дел с нумерацией;
  - удаления дела по его номеру. Если нет дела с таким номером, об этом нужно написать пользователю;
  - удаления дела по его точному тексту. Если нет дела текст которого совпадает с искомым текстом, об этом нужно написать пользователю;
  - выход из программы.
    
  Пользователю на повторе должно предлагаться меню с операциями на выбор. После каждой операции должен выводиться пронумерованный список всех дел.
- **2 задание**.
Добавьте операцию удаления по ключевому слову. При такой операции пользователь вводит слово, а из списка удаляются все задачи, которые это слово содержат.

---

Homework 14 -
- **1 задание**.
Вашей задачей будет написание сервиса услуг доставки товаров по миру.
Адрес доставки будет задаваться двумя данными: страна (country) и город (city). Создайте для этих целей класс Address.
В main создайте несколько адресов и мапу costPerAddress, в которой ключом будет адрес, а значением — цена доставки 1 кг груза.
Заполните мапу созданными адресами и произвольными значениями цен доставки по этим адресам.
Далее в цикле пользователь вводит заказы (или end). Каждый заказ состоит из трёх частей: страны, города и веса в кг доставляемого товара.
В ответ нужно написать, что такой адрес не обслуживается, или написать стоимость доставки и общую сумму всех сделанных доставок.

- **2 задание**.
Добавьте, кроме общей суммы, вывод информации о том, в какое количество уникальных стран были оформлены доставки.
Уникальность означает, что если по России было отправлено, например, три заказа, то учитываться это должно как одна страна.

---

Homework 15 -
- **1 задание**.
Перед вами программа отбора кандидатов в астронавты. В main заполнено множество из потенциальных кандидатов, из которых выбирается только два кандидата.

  Критерии отбора таковы. При сравнении двух кандидатов лучший выбирается по принципу:
  - тот у кого больше опыта; если опыт одинаковый то
  - тот, у кого в имени с фамилией (т.е. name) больше букв s или S (от слова space - космос; было решено, что медийность - важная часть космонавтики); если по этому критерию оказываются равны, то
  - тот, у кого имя с фамилией (т.е. name) короче (так легче будет запоминать имена астронавтов по всему миру)

  Ваша задача реализовать компаратор, сортировка которым расставит кандидатов по убыванию их приоритета найма в астронавты.
  Программа в main в итоге должна выводить имена двух самых лучших кандидатов.

---

Homework 16 - 
- **1 задание**.
Вы начинающий мастер по маникюру. Вы знаете, что делаете свою работу достаточно хорошо, так что каждый новый клиент с вероятностью 50% приведёт своего друга.
У вас есть список первых клиентов. Каждого клиента можно описать просто строкой:
List<String> firstClients = List.of(“Anya”, “Sveta”, “Olya”, “Alexandra”, “Ruslana”, “Olesya”, “Vika”);

  Создайте Queue-коллекцию из этих клиентов. Каждого клиента вы принимаете в порядке очереди. В конце обработки каждого клиента с вероятностью 50% записывается его друг. В Java сэмулировать эту вероятность можно так:

  ```java
  if (Math.random() < 0.5) { // проверка условия, которое срабатывает с 50% вероятностью
  // друг записался
  } else {
  // друг не записался
  }
  ```
  
  Имя другу можно сгенерировать из имени того, чьим другом он является через фразу a friend of. Например, если порекомендовала Sveta, то друга будут звать a friend of Sveta. Если и её друг порекомендует, то такого друга будут звать a friend of a friend of Sveta. Новый записывающийся всегда встаёт в конец очереди.
  Напишите программу, которая будет разбирать очередь из клиентов, с вероятностью 50% добавляя нового клиента после обработки текущего клиента.
  В качестве обработки клиента достаточно выводить на экран фразу виду: <имя> сделал новый маникюр. Например, Alexandra сделала новый маникюр.

---

- **Course paper** -

  Вас пригласили поучаствовать в разработке приложения, 
  умеющего скачивать картинки по URL и конвертировать изображения в текстовую графику (т. е. в текст из разных символов, которые в совокупности выглядят как изображение).

---

- Git 1 -
- **1 задание**.
  В предыдущем задании вы создали локальный репозиторий. Чтобы продемонстрировать результат коллегам вам нужно опубликовать его на GitHub.
  - Найдите на рабочем столе папку NeuroStartUp. Вы создали её в процессе решения квиза к предыдущей лекции. Откройте для неё терминал.
  - На сайте GitHub создайте новый пустой публичный репозиторий. Скопируйте ссылку на него.
  - В терминале свяжите локальный репозиторий с удалённым. Используйте кодовое слово origin.
  - Опубликуйте репозиторий на GitHub. Для этого используйте команду git push -u origin main
  - Перезагрузите страницу с репозиторием в браузере. Убедитесь, что в репозитории есть файл README.md, текст правильно отображается и видна вся история проекта.

- **2 задание**.
  Вы решили немного доработать главную страницу вашего проекта. Но новый текст требует согласования, команда не готова сразу его менять. Они попросили показать как это будет выглядеть. Для этого вам нужно создать новую ветку и добавить туда новый текст.
  - Найдите на рабочем столе папку NeuroStartUp. Откройте для неё терминал.
  - Создайте новую ветку с названием new-text и переключитесь на неё.
  - Откройте файл README.md в текстовом редакторе и вставьте новый текст ниже того, что там уже есть. Нажмите на треугольник ниже, скопируйте текст, вставьте в файл и оформите при помощи Markdown, чтобы он выглядел как в примере:
  - Текст для вставки в файл README.md
  - Сделайте коммит с изменениями.
  - Отправьте коммит в репозиторий: git push -u origin new-text.
  - Откройте репозиторий на GitHub в браузере, переключитесь на ветку new-text и скопируйте ссылку из адресной строки браузера.

---

- Git 1.3 -
- **3 задание**.
  Пока новый текст для главной страницы находится на согласовании вас попросили поработать над другим проектом. Ваш коллега закончил работу над новой фичей и её нужно слить в ветку main.
  - Склонируйте репозиторий по ссылке на рабочий стол.
  - Откройте терминал для появившейся после клонирования папки.
  - Прочитайте справку под задачей.
  - Слейте ветку earlyorder с веткой main.
  - Разрешите появившийся при слиянии конфликт. Оставьте один вариант текста на ваше усмотрение.
  - Создайте новый пустой публичный репозиторий на GitHub.
  - Свяжите ваш локальный репозиторий с только что созданным удалённым репозиторием. При связывании используйте кодовое слово target. Команда будет выглядеть так: git remote add target ссылка-на-пустой-репозиторий.
  - Отправьте локальные изменения ветки main в удалённый новый репозиторий target. Полностью команда будет выглядеть так: git push -u target main.

---

- Git 2.1 -
- **1 задание**.
  Вам предоставили исходники лендинга, но в виде zip-архива. Вам нужно перенести их в систему контроля версий Git и опубликовать на GitHub.
  Обратите внимание, что в архиве есть мусорные файлы и системные файлы (папка tmp, файлы, заканчивающиеся суффиксами _old, _backup, Thumbs.db и .DS_Store) и их нужно проигнорировать, так как в противном случае получится, что вы храните ненужные файлы.
  - Скачайте по ссылке архив с проектом.
  - Распакуйте из него папку Site For Import. В архиве также лежит скрытая папка __MACOSX, она не нужна для работы. Удалите эту папку с вашего компьютера.
  - Создайте на базе папки Site For Import Git-репозиторий.
  - Проигнорируйте подкаталог tmp/ и файлы, заканчивающиеся суффиксами _old, _backup. Любые символы можно заменить символом звёздочка *.
  - Добейтесь чтобы также были проигнорированы файлы Thumbs.db и .DS_Store.
  - При помощи команды git status убедитесь, что Git не видит ненужные файлы.
  - Добавьте в индекс все файлы проекта, включая .gitignore. Создайте коммит изменений.
  - Создайте отдельный репозиторий на GitHub.
  - Свяжите ваш локальный репозиторий с только что созданным удалённым репозиторием. Используйте в качестве кодового слова для связи с удалённым репозиторием origin.
  - Отправьте сделанные вами изменения на GitHub.

---

- Git 2.2 -
- **2 задание**.
  Один из ваших коллег во время работы над сайтом допустил ряд ошибок и залил всё вместе с ошибками в репозиторий на GitHub. Вам нужно отменить его последний коммит и исправить ситуацию.
  - Склонируйте Git-репозиторий по ссылке.
  - Отмените один последний коммит в проекте при помощи команды git revert.
  - Создайте отдельный репозиторий на GitHub.
  - Свяжите ваш локальный репозиторий с только что созданным удалённым репозиторием. При связывании используйте кодовое слово target поскольку стандартное кодовое слово origin уже занято.
  - Отправьте сделанные вами изменения на GitHub.

---

- Git 2.3 -
- **3 задание**.
  Вы с коллегой вдвоём работаете над одним проектом. Вы доделали свою часть работы и пытаетесь запушить изменения в удалённый репозиторий. Но оказалось, что коллега изменил тот же файл раньше вас и уже отправил свой коммит. Вам нужно забрать изменения из удалённого репозитория, разрешить конфликт и всё же отправить свою часть работы на GitHub.
  - Сделайте форк репозитория по ссылке.
  - Скачайте архив изменений. Распакуйте из него папку git-2-homeworks-fork.
  - Свяжите локальный репозиторий из архива с форком репозитория из п.1.
  - Выполните команду git push -u origin main, прочитайте сообщение об ошибке отправки изменений.
  - Заберите актуальную версию данных из удалённого репозитория при помощи команды git pull origin main.
  - Разрешите появившийся конфликт и отправьте сделанные вами изменения на GitHub.
    
---

- Git 3.1 -
- **1 задание**.
https://github.com/netology-code/git-2-homeworks-issues/issues/8118
Вы заметили, что при просмотре лендинга вашей компании в мобильном браузере текст наезжает на картинку.
Поскольку теперь для управления проектами вы используете GitHub, создайте Issue с описанием проблемы (пример описания). Не забудьте приложить скриншот и отметьте в тексте Issue пользователя @solarrust.

  Для выполнения этого задания не нужно использовать блок assign при создании issue.
  - Откройте проект по ссылке.
  - Зайдите в раздел Issues и создайте новый Issue (пример описания).
  - Отметьте в тексте Issue пользователя @solarrust.

---

- Git 3.2 -
- **2 задание**.
https://katrinadevlop.github.io/Papkaw/
  В один день вам в голову пришла мысль поучаствовать в развитии Open Source проекта. Среди задач (issues) в этом проекте есть та, что вам как раз по силам. Нужно просто вставить пару строк в файл README.md.
  - Сделайте форк репозитория по ссылке.
  - Внесите изменения в проект согласно описанию в Issue.
  - Создайте Pull Request ваших изменений в репозиторий Нетологии (ссылка в первом пункте текущего задания).
  
---

- Git 3.3 -
- **3 задание**.
  Пришло время начать собирать собственное портфолио. Вы решили пока не тратить деньги на покупку хостинга и домена, а воспользоваться GitHub Pages. Начнём с малого и создадим файл, в котором вы раскажете немного о себе, а потом опубликуем этот файл. Получится целый сайт!
  - Создайте на компьютере локальный репозиторий с любым названием.
  - Внутри папки репозитория создайте файл README.md. Внутри напишите любую информацию о себе, добавьте фото. Используйте возможности Markdown по полной. Не забывайте пользовать предпросмотром в редакторе.
  - Откройте терминал для этой папки и создайте коммит с изменениями.
  - Создайте новый пустой публичный репозиторий на GitHub.
  - Свяжите локальный репозиторий с новым удалённым.
  - Отправьте коммит(-ы) в удалённый репозиторий.
  - В репозитории на GitHub перейдите на вкладку Settings, в боковой колонке найдите пункт Pages.
  - Опубликуйте ваш репозиторий на GitHub Pages. По желанию изучите другие возможности этой функции.

---

Homework 17 -
- **1 задание**.
По образцу, который мы разбирали на лекции, создайте проект, выводящий в консоль First App!.

  При этом:
  - groupId: ru.netology;
  - artifactId: HelloKotlin.

При создании проекта используйте следующие настройки. Версию JDK можно ставить любую, выше 11.

---

Homework 18 -
- **1 задание**.
Мы решили дать пользователям нашей социальной сети возможность отправлять друг другу денежные переводы. Система будет удерживать комиссию 0.75 %, при этом минимальная комиссия составит 35 рублей.
Напишите небольшую программу, которая будет высчитывать размер этой комиссии в зависимости от суммы перевода.

  Требования к программе:
  - В переменной amount хранится сумма перевода в рублях.
  - Программа выводит в консоль размер комиссии в зависимости от суммы перевода (также в рублях).

---
  
Homework 18.2 -
- **2 задание**.
В интерфейсах приходится изменять окончания слов после числительных, а иногда и формы слов: «понравилось 32 людям», но «понравилось 41 человеку». Напишите программу, которая будет выдавать количество лайков, правильно согласованное со словом «человек» или «люди».

  Требования к программе:
  - В переменной likes хранится число лайков.
  - В зависимости от того, что хранится в likes, приложение выводит ответ в консоль в таком виде: «Понравилось … людям (человеку)»
  
---

Homework 18.3 -
- **3 задание**.
Мы решили мотивировать пользователей покупать больше музыки с помощью скидки: чем большую сумму потратит пользователь, тем большую скидку он получит.
Условия акции таковы. Если сумма покупки:

  Условия акции
  - от 0 до 1 000 рублей — скидка не предоставляется
  - от 1 001 до 10 000 рублей — скидка составит 100 рублей (как в лекции)
  - от 10 001 рубля и выше — скидка составит 5% от суммы.
    
  Все цены указаны в рублях.
  Те, кто приобретает музыку ежемесячно, попадают в отдельную категорию — постоянные покупатели. После стандартной скидки к получившейся сумме применяется дополнительная — ещё 1% сверху.
  Напишите программу, которая будет выводить в консоль итоговую стоимость покупки после применения скидок в зависимости от статуса покупателя (обычный или постоянный).

---

Homework 19.1 -
- **1 задание**.
Социальные сети и мессенджеры показывают, когда ваш собеседник последний раз был онлайн.
Используя when, напишите функцию agoToText, которая учитывает, сколько времени прошло с последнего визита пользователя, и выдаёт в консоль результат проверки в следующем виде: «был(а) только что», «был(а) 3 часа назад» и т. п.

  Какие правила стоит учесть
  - Если количество секунд от 0 до 60, консоль выводит вариант «был(а) только что».
  - Если количество секунд от 61 до 60 * 60 (один час) — вариант «был(а) x минут назад».
  - Если количество секунд от 60 * 60 + 1 до 24 * 60 * 60 (сутки) — вариант «был(а) x часов назад».
  - Если количество секунд от суток до двух — вариант «был(а) вчера».
  - Если количество секунд от двух суток до трёх — вариант «был(а) позавчера».
  - Если количество секунд больше трёх суток — вариант «был(а) давно».
  - Вам понадобятся вспомогательные функции, которые выбирают правильные формы слов «минута» и «час».

  Для минут:
  - 1 / 21 / 31 / 41 / 51 минуту назад
  - 2 / 22 / 32 / 42 / 52 минуты назад (то же самое для 3 и 4)
  - 5 / 25 / 35 / 45 / 55 минут назад (то же самое для 6-9, но помните, что с 60 минут результат выводится уже в часах)
  - 11 / 12 / 13 / 14 минут назад.

  Для часов:
   - 1, 21 час назад
   - 2, 3, 4, 22, 23, 24 часа назад
   - 5-20 часов назад.

---

Homework 19.2 -
- **2 задание**.
В прошлый раз мы рассматривали упрощённый вариант вычисления комиссии. Давайте усложним задачу. Теперь сумма комиссии будет зависеть ещё и от типа карты, с которой мы переводим средства. 
  - За переводы с карты Mastercard комиссия не взимается, пока не превышен месячный лимит в 75 000 руб. Если лимит превышен, комиссия составит 0,6% + 20 руб.
  - За переводы с карты Visa комиссия составит 0,75%, минимальная сумма комиссии 35 руб.
  - За переводы с карты Мир комиссия не взимается.

   Кроме того, введём лимиты на суммы перевода за сутки и за месяц. Максимальная сумма перевода с одной карты:
  - 150 000 руб. в сутки
  - 600 000 руб. в месяц
  - Комиссия в лимитах не учитывается.

  Напишите алгоритм расчёта в виде функции, передавая в функцию:
  - тип карты (по умолчанию Мир);
  - сумму предыдущих переводов в этом месяце (по умолчанию 0 рублей);
  - сумму совершаемого перевода.
  - В случае превышения какого-либо из лимитов операция должна блокироваться.
    
---


Homework 20 -
- **1 задание**.
Денежные переводы ВКонтакте. Отправляйте деньги в сообщениях, используя банковскую карту. Номер карты получателя не нужен - он сам решит, куда зачислить средства.

   Комиссия
  - За переводы с карт Mastercard и Maestro - не взимается при сумме
  перевода от 300 рублей и до 75000 рублей в календарный месяц в
  рамках акции(*), в иных случаях - 0,6% + 20 рублей.
  - За переводы с карт Visa и Мир - 0,75%, минимум 35 рублей.
  - За переводы на счёт VK Рay - не взимается.

  Максимальная сумма переводов по одной карте - 150000 рублей в сутки и 600000 рублей в месяц раздельно на отправку и на получение. Комиссия в лимитах не учитывается.
  Максимальная сумма переводов со счёта VK Рay - 15000 рублей за один раз и 40000 рублей в месяц.
  Подключите JUnit4 и JaCoCo. Добейтесь того, чтобы покрытие кода по branch было не менее 80 % на все функции.

- **2 задание**.
Подключить к вашему репозиторию GitHub Actions.
Чтобы удостовериться, что CI работает, добавьте коммит, ломающий сборку: выставьте в тестах неправильное ожидаемое значение. Убедитесь, что после Push вам покажут эту проблему.
Важно: вам не нужно каждый раз создавать заново файл конфигурации GitHub Actions. Достаточно добавлять его в новый репозиторий так же, как вы это делаете с .gitignore.

---

Homework 21 -
- **1 задание**.

На этом этапе мы будем не только решать вычислительные задачи, но и моделировать системы.
В качестве примера возьмём ВКонтакте: https://vk.com/dev/objects/post. Если страница недоступна, воспользуйтесь копией из каталога assets).
    Что мы хотим получить:
    - Data-класс Post (и другие классы, которые могут быть вложены в Post).
    - Объект WallService, который хранит посты в массиве.

- **2 задание**.
Теперь нужно разобраться с функциональностью сервиса, отвечающего за стены пользователей: https://vk.com/dev/wall (копия).

  Нас будут интересовать следующие методы:
  - создание записи;
  - обновление записи.
  
- **3 задание**.
  Следующая задача – написать автотесты на ваши методы:
  - на add – всего один, который проверяет, что после добавления поста id стал отличным от 0.
  - на update – целых два:
    - изменяем пост с существующим id, возвращается true;
    - изменяем пост с несуществующим id, возвращается false.

---
(Еще задание в этой ветке)
Homework 21 -
- **1 задание**.
Доработайте первую задачу из предыдущей лекции так, чтобы в классе Post некоторые поля были Nullable (на ваш выбор).

  Итог
  - Data-класс Post.
  - Внутри Post могут быть Nullable-свойства.
  - WallService, который хранит посты в массиве.
    
Вы можете оформить это как Pull Request к предыдущему проекту (присылайте в личном кабинете ссылку на PR).

- **2 задание**.
Следующая задача: разобраться с вложениями у постов - attachments (прямая ссылка/сохранённая копия).
В данном массиве могут храниться объекты разной структуры. В объектах массива есть поле type, а второе поле может быть различным (оно определяется на базе значения поля type: в первом случае Photo, во втором —Video). Для организации подобной структуры будет удобно применить наследование.

  Возможны два варианта:
  - сделать Attachment интерфейсом,
  - сделать Attachment абстрактным классом.
    
  В обоих вариантах нужно добавить в Attachment поле type, а после описать наследников Attachment, которые уже будут хранить специфичные данные (фото, аудио, видео). Эти данные (то, что вложено в наследников Attachment) лучше оформить в виде отдельных классов - Audio, Video и так далее. Т.е. для одного типа вложения будут отдельные классы: AudioAttachment и Audio. Не забывайте, что в Kotlin не обязательно каждый класс описывать в отдельном файле, а можно в одном описать сразу несколько, что будет особенно удобно в этой задаче.
  Вам необходимо добавить к классу Post массив из объектов Attachment и описать классы Attachment, его наследников и классы для хранения данных о вложениях.
  Вы можете оформить это как Pull Request к задаче №1 (присылайте ссылку в личном кабинете на PR).
  Важно: после ваших обновлений WallService должна оставаться функциональной. Т.е. автотесты должны проходить.

- **3 задание**.
В Kotlin предыдущую задачу можно решить с помощью запечатанных (sealed) классов.
Важно: после ваших обновлений WallService должна оставаться функциональной,т.е. автотесты должны проходить.

--- 


